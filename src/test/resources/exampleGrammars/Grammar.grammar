START: S
EPS: epsilon

// Structures:
NTERM: VAL TYPE
NTERM: OP UNARY ARITH_OP LOGIC_OP COMPARE_OP
NTERM: S CLASS_CNT BLOCK_CNT
NTERM: STATEMENT STMT PRINT
NTERM: DECLARATION ASSIGNMENT
NTERM: PAR_EXPR EXPR EXPR_2 EXPR_F
NTERM: LOOP COND COND_ELSE SINGLE_OR_BRACED

// Token:
TERM: CLASS PUBLIC STATIC
TERM: STRING_TYPE INTEGER_TYPE BOOLEAN_TYPE VOID_TYPE
TERM: WHILE IF ELSE
TERM: PRINTLN
TERM: ADD MUL SUB DIV MOD
TERM: AND OR NOT
TERM: LESS LESS_EQUAL GREATER GREATER_EQUAL EQUAL NOT_EQUAL
TERM: ASSIGN
TERM: L_BRACE R_BRACE L_BRACKET R_BRACKET L_PAREN R_PAREN SEMICOLON COMMA DOT
TERM: INTEGER_LIT STRING_LIT BOOLEAN_LIT
TERM: IDENTIFIER IDENTIFIER_MAIN

// Actions: compact - Value hochreichen
//          nullable - Kann entfernt werden, wenn keine value und keine children

// General -----------------------------------------------------------------------------------------

VAL[compact] -> INTEGER_LIT | STRING_LIT | BOOLEAN_LIT | IDENTIFIER
TYPE[compact] -> INTEGER_TYPE | STRING_TYPE | BOOLEAN_TYPE

OP[compact] -> ARITH_OP | LOGIC_OP | COMPARE_OP
UNARY[compact] -> ADD | SUB | NOT
ARITH_OP[compact] -> ADD | SUB | MUL | DIV | MOD
LOGIC_OP[compact] -> AND | OR | NOT
COMPARE_OP[compact] -> LESS | LESS_EQUAL | GREATER | GREATER_EQUAL | EQUAL | NOT_EQUAL

// -------------------------------------------------------------------------------------------------

// class IDENTIFIER { CLASS_CNT }
S[compact] -> CLASS IDENTIFIER L_BRACE CLASS_CNT R_BRACE | EPS

// public static void main(String[] args) { BLOCK_CNT }
CLASS_CNT -> PUBLIC STATIC VOID_TYPE IDENTIFIER_MAIN L_PAREN STRING_TYPE L_BRACKET R_BRACKET IDENTIFIER R_PAREN L_BRACE BLOCK_CNT R_BRACE
CLASS_CNT[compact nullable] -> EPS

// Stuff in {}
BLOCK_CNT[compact nullable] -> STATEMENT BLOCK_CNT | L_BRACE BLOCK_CNT R_BRACE | EPS

STATEMENT -> STMT SEMICOLON
STATEMENT[compact] -> LOOP | COND
STMT[compact] -> PRINT | DECLARATION | ASSIGNMENT
PRINT -> PRINTLN PAR_EXPR

// Declaration with Assignment: TYPE IDENTIFIER = LITERAL;
DECLARATION -> TYPE ASSIGNMENT
ASSIGNMENT -> IDENTIFIER ASSIGN EXPR

// Stuff that returns something
PAR_EXPR -> L_PAREN EXPR R_PAREN
EXPR[compact] -> EXPR_F EXPR_2
EXPR_2[compact nullable] -> OP EXPR_F EXPR_2 | EPS
EXPR_F[compact] -> UNARY EXPR_F | PAR_EXPR | VAL

// Control-Flow
SINGLE_OR_BRACED -> L_BRACE BLOCK_CNT R_BRACE | STMT SEMICOLON
LOOP -> WHILE PAR_EXPR SINGLE_OR_BRACED
COND -> IF PAR_EXPR SINGLE_OR_BRACED COND_ELSE
COND_ELSE[compact nullable] -> ELSE SINGLE_OR_BRACED | EPS
